LA CTF 2024 
=====

This CTF was really interesting with very unique challenges and I was only able to solve 4 crypto challenges. 

---

## crypto/valentines-day

>Happy Valentine's Day! I'm unfortunately spending my Valentine's Day working on my CS131 homework. I'm getting bored so I wrote something for my professor. To keep it secret, I encrypted it with a Vigenere cipher with a really long key (161 characters long!)
>
>As a hint, I gave you the first part of the message I encrypted. Surely, you still can't figure it out though?
>
>Flag format is lactf{xxx} with only lower case letters, numbers, and underscores between the braces.

#### *ct.txt*
```txt
Br olzy Jnyetbdrc'g xun, V avrkkr gb sssp km frja sbv kvflsffoi Jnuc Sathrg. Wkmk gytjzyakz mj jsqvcmtoh rc bkd. Canjc kns puadlctus!

L xyw fmoxztu va tai szt, dbiazb yiff mt Zzhbo 1178 gyfyjhuzw vhtkqfy sniu eih vbsel edih tpcvftz, xcie ysnecsmge hbucqtu qt wcorr crzhg-olhm srr gkh gdsjxqh gnxxl rtr guez jewr klkkgak dx uuka nnv hmvwbj gmv glz fvyh, jueg eww oq i wuqglh Z lrigjsss ynch xun esivmpwf: "oof hvrb frtbrq it Kcmlo?"

C ltzihfvxsq ghp abqs qrfzf glvx de HN bnty gocr gr:

Eiaj zek rvocf vnriiu ob Puiza. Xegjy webrvbvrj. Frat s vgxhidm kepldrv gbq phxgv.

Ehlb'w wuhu C ixyzchlr, ilc srez foq e wxzb sdz nrbrb. Eej W und siieesx nd pvvgb zvr pooi. B fox wc nrax v pedgei aex phvqe. Hqdru pc tvvtrv, C zyoxvxsq ghq wyvbg yzgmex KEKN=/ife/lgcyr/qg/ejl:$TNXC, eej hurn mlp qowtswvqn:

wrm ~cuamyh/umlofikjayrvplzcwm.gdg | pzwj
ropgf{qvjal_dfuxaxzbk_gbq_jeci_hdt_nr_hdr_eexij}

Yiqqeefl, cywfylnt zlrv finqvyq sqii sm oncw.

Apxcf ipv yah v lrrt ubujs, rnsm kbb jvrvpce anaazio eo ecvn bq abv TA wh bos aiahovr qojp.

L vhclachyyc mirj hueoaoc xfs uhhjim ove, gybwwc vmdslbc qbai xyk fvthk uasnslf rngr pc dsez, rvcpo vrjcse fhqed afsh K ycnv Zkxkfg fcjeys Q-g Vushrro Ayu Wf Phxeetnr Wjf Gkl Uelusl Slm xr fwm rncwti hfhkk lcamhi. D ary wa gozig wfcwe. Humqiiobt, V lzsdcr xrkj ng xci wxcag ow nue tzufvrbrp, efh ntrqbrh vw Vmuret elyajm nwilrh cmj nsnq uftgr wh opaorh jrku ar. "V wbpw akttp ybx," oy vvfcyl. P kpw dfidrw or qb wlac sbq ibygh ftzl jazkc eq vy mjzqjrvj vvf seegb [PCUHDCYEXI FL HUR IENRRESN].

V eorowiv jihk as fivx, aaacvns ofip gyxvpnp prcaqxl slubkbhv' ecwxw vru ydevnmmyr ua ble fwhcil ybx wbh dj Dfurm rbrs wal Kgmfg us Wxmvtqrf. Bab D gmifx hrrni knog Rgrikr kuv qhbfi jr de hnvl. Yy fudaiahd n grdwr thnwyf sa lzsgryf iidl aofnj rb tolikoq_prwark(), obg ufil tmstksqrd ms nsadm qe nv P lrg rcqiyrh xfs gegqgam enptvabt. O uenxzrm teahjzh rvy xdbv os vthre mlxaqqc, zvaa brz sw zvr Rgxyet kvlrddf vksmxvw "avgbh v-b DGHUFCU DYSP." W ntzcq skieobt ghw dmuf, pxu gx fljykkr ng mx: "Tpcmtawibq kyebcr." C ahws "vk -t xsba" olh utu qflc gnr qvxyyqv ouotymlu.

C lpa hzwgkfngewc ypcg wva Rtkzvk izbaej, vht jcia iohqg qqwved cog sa fikogu, bqckyqs C'o r AF qvnfx oaq I kir gh ab ecwx egp ugm. Fhdwiywy, T aew bql iw Xeuyza'g rpmbyw edb bszg apw zoyrjet. M hawpxle wkilsx nwr hjsi tskg tz qx ybx vhacciy meywqr, biyntywht d svjk sx vvegsz. Oyo xykb V gudnoh kmmgcd nvjyej oaq surcgasg.

"Xcppshi ku al bfymnp." Eroirg hjbfxb. "Mic'cs bebs cx fx tyv. L vhv lwzy zueo cfa vnie g ojsb uluhc sa xyk thadlqxlhuog ks pshqftzl-hsvx fowhqnue grrpk eew cbpvvjrdkbgf, pmrdmaifcijl skie-ychecw tmuzg ojiiyc os sk ifrd br fappz-hiilzcfg acgxbhtv qqcials asxkzmk."

A kuoztzvvj oaq bgkfib whnd glz gfxbre oq lbq cziwyr.

"Lsp qre pr joexrrzba urw lrx kgx yxps. C pvzekkr n fyybypgq fkei oioavkb zntzsao 6229 obg nw ssjdgv nser ig Iyriymirvqn PZ. B uohb fcj xm yhsj cvyx L pvv'l ziez lsp. M ngg zrrktt xcgncct cjy."

Z miyceo egb ziryaq vros yog rlej. "Lraczs?"

"Lhs..." Rjjijx ixnzcrh, "Dr wgqg, V bdoekfh sql frvz mezc zl oxfgis hr bqo lsp sek jrey bqazreirt dxlmkbmb."

"Qphh?" X wrinxrasb.

Ijzlzl dsntrh wetq wa uiy kcegf, mgxymik. "Pui fre, qsk rvy soog fiqiigz lraim V hrjy ohea exmdhzge ij n xzed ut uvgtli gydudcc vrymmorhnlk, olkg hkbr gnr vrkoqvcami qzrpqkn pbiyilcqozphn xffyegb tpsp isiuwg fapl vw LYQ nad ybjt rvyg. X hwz xyk qynsd GL35J wh rfzre xj wfxh gurfoth rzf bi UPOD'w mruxpulnhpekk QF ftgdorrg, upu dvry xyk cars oirn hvh qmxrromrr hb wobr esid tiatxl iw vwpyz osgscg."

"Nlnc'g... Rldm'z qehcfyvfgi..." Z yovq.

"Yuc kvmpuval lvzvt'h erawmscr cw mag," Rkbiiz skclrcaeu, "pog zhvoh vmreblu ujet jiua zr yau gips udcc gs pxzrwmr a eujzwhxec ss pdrld qbzmtrod iy wvdru ai vlaojm tm lvyhb. Hb hcs yqwlzkloaj jlvx knog zegvn?"

"Yf...." W muxq, vzeconvag tx pyg kxwpr fxmeems V jaj uolv hi ihrodopq mevybnnxz kea qbeegtspq, "m-sgrf, V kpijy...?"

Sttejt egnsg tm hrikpp obgb mr wzfl T nilg dz cw ac vul yic xfs wszvolh whw wf em vtgimrrr cetata. "Esgb gy, pah osxkhurr hi pgzf finir hjae zvr joifq."

sfilph: hgwsw://oan.kcrxvx.xsd/x/ipya/oowqcbnu/s2b4md/hc_vddreiwnak_kwwi_rlr_gn35p_wobny/

```

#### *intro.txt*
```txt
On this Valentine's day, I wanted to show my love for professor Paul Eggert. This challenge is dedicated to him. Enjoy the challenge!
```

### Solution
We are given a text file **ct.txt** which looks to be encrypted by the _Vigenere Cipher_ and an **intro.txt** which is the unciphered part of the first paragraph. We can first try to obtain the key using the first paragraph.

```python
alphabets = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z".split(sep=" ")
print(alphabets)

ct = "Br olzy Jnyetbdrc'g xun, V avrkkr gb sssp km frja sbv kvflsffoi Jnuc Sathrg. Wkmk gytjzyakz mj jsqvcmtoh rc bkd. Canjc kns puadlctus!".upper()
pt = "On this Valentine's day, I wanted to show my love for professor Paul Eggert. This challenge is dedicated to him. Enjoy the challenge!".upper()
key = ""

for i in range(len(ct)):
    if ct[i] not in alphabets:
        continue
    index = (alphabets.index(ct[i]) - alphabets.index(pt[i])) % 26
    key += alphabets[index]
print(key)
print(len(key))
```

The key we obtain from this is:

##### NEVERGONNAGIVEYOUUPNEVERGONNALETYOUDOWNNEVERGONNARUNAROUNDANDDESERTYOUNEVERGONNAMAKEYOUCRYNEVERGONNASAYGOO                                                   

This key is only 106 characters long which means we are still missing 55 characters of the key. Since it's obvious that this key is based on *Rick Roll*, we can just fill in the rest of the chorus as the key.

##### NEVERGONNAGIVEYOUUPNEVERGONNALETYOUDOWNNEVERGONNARUNAROUNDANDDESERTYOUNEVERGONNAMAKEYOUCRYNEVERGONNASAYGOODBYENEVERGONNATELLALIEANDHURTYOU                                                      

Now we are still missing 23 characters of the key, but it should be alright if we just append some 23 long characters into the end to make sure the key loops correctly, then we should be able to observe some parts of the text unencrypted. 

![cyberchef](https://github.com/solaris0141/CTF-Writeup/edit/main/LACTF2024/cyberchef.png)


### Flag
>lactf{known_plaintext_and_were_off_to_the_races}


## crypto/very-hot

>I didn't think that using two primes for my RSA was sexy enough, so I used three.

#### *src.py*
```python
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from flag import FLAG

FLAG = bytes_to_long(FLAG.encode())

p = getPrime(384)
while(not isPrime(p + 6) or not isPrime(p + 12)):
    p = getPrime(384)
q = p + 6
r = p + 12

n = p * q * r
e = 2**16 + 1
ct = pow(FLAG, e, n)

print(f'n: {n}')
print(f'e: {e}')
print(f'ct: {ct}')

```
### Solution

At first glance this is a RSA with 3 primes, and the rest pretty much follow the textbook style of encryption. First of all, I immediately attempted to factorize the modulus with **factordb** and surprisingly I manage to obtain the 3 primes already. The decryption process is pretty much textbook from here onwards. 

```python
from Crypto.Util.number import *

p = 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842077
q = 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842083
r = 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842089

n = p * q * r
e = 2**16 + 1
ct = 9953835612864168958493881125012168733523409382351354854632430461608351532481509658102591265243759698363517384998445400450605072899351246319609602750009384658165461577933077010367041079697256427873608015844538854795998933587082438951814536702595878846142644494615211280580559681850168231137824062612646010487818329823551577905707110039178482377985
phi = (p-1)*(q-1)*(r-1)
d = pow(e,-1,phi)

print(long_to_bytes(pow(ct,d,n)))
```

### Flag
> lactf{th4t_w45_n0t_so_53xY}


## crypto/selamat pagi

>If you talk in another language, nobody can understand what you say! Check out this message I sent in Indonesian. To add some extra security, I also applied a monoalphabetic substitution cipher on it!

#### **message.txt**
```txt
Efe kqkbkx czwkf akfs kdkf qzfskf wzdcjtfk
Ieqku kqk akfs ikxj kck akfs wkak ukikukf :Q
Lzfqztk ukdj kqk qe wefe: bkvim{wzbkdki_ckse_kckukx_ukdj_wjuk_kfkbewew_mtzujzfwe}
```

### Solution

Looking at the challenge statement we can roughly expect that the decrypted text will be in Indonesian. For this challenge, I actually managed to solve it without needing to use any frquency analysis. I substituted the known words such as **lactf** and then eventually finding out some of the Indonesian words. The whole text was decrypted easily after I found out that the flag started with the challenge title **selamat pagi**

#### **Original Text**
```txt
Ini adalah pesan jang aman dengan sempurna
Tidak ada jang tahu apa jang saja katakan :D
Bendera kamu ada di sini: lactf{selamat_pagi_apakah_kamu_suka_analisis_frekuensi}
```

### Flag
> lactf{selamat_pagi_apakah_kamu_suka_analisis_frekuensi}

## crypto/hOlyT

>God is trying to talk to you through a noisy wire Use nc chall.lac.tf 31171 to talk to him.

#### **server.py**
```python
from Crypto.Util.number import getPrime, bytes_to_long
import random
def legendre(a, p):
    return pow(a, (p - 1) // 2, p)

def tonelli(n, p):
    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1
    if s == 1:
        return pow(n, (p + 1) // 4, p)
    for z in range(2, p):
        if p - 1 == legendre(z, p):
            break
    c = pow(z, q, p)
    r = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    t2 = 0
    while (t - 1) % p != 0:
        t2 = (t * t) % p
        for i in range(1, m):
            if (t2 - 1) % p == 0:
                break
            t2 = (t2 * t2) % p
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = (b * b) % p
        t = (t * c) % p
        m = i
    return r
def xgcd(a, b): 
    if a == 0 : 
        return 0,1
             
    x1,y1 = xgcd(b%a, a) 
    x = y1 - (b//a) * x1 
    y = x1 
     
    return x,y 
def crt(a, b, m, n):
    m1, n1 = xgcd(m, n)
    return ((b *m * m1 + a *n*n1) % (m * n))

def advice(x, p, q):
    if legendre(x, p) != 1:
        exit()
    if legendre(x, q) != 1:
        exit()
    x1 = tonelli(x, p) * random.choice([1, -1])
    x2 = tonelli(x, q) * random.choice([1, -1])
    y = crt(x1, x2, p, q)
    return y

def main():
    p = getPrime(1024)
    q = getPrime(1024)
    N = p * q
    e = 65537
    m = bytes_to_long(b"lactf{redacted?}")
    ct = pow(m, e, N)
    print(f"ct = {ct}")
    print(f"N = {N}")
    print(f"e = {e}")
    while 1:
        x = int(input("What do you want to ask? > "))
        ad = advice(x, p, q)
        print(ad)

if __name__ == "__main__":
    main()

```

Observing this at first, it encrypts the flag with RSA and then allows us to ask for an "advice", which is just the square root modulus of the number we inputted. The advice function essentially does this: 

1. We input our number **x**
2. Checks if **x** is a quadratic residue of **p** and **q** by using _Legendre's Symbol_.
   
$$a/p \equiv a^{\frac{p-1}{2}} \mod n$$
>(a / p) = 1 if a is a quadratic residue and a ≢ 0 mod p  
>(a / p) = -1 if a is a quadratic non-residue mod p

4. Uses the _Tonelli Shanks Algorithm_ to find the square root of **x** modulus **p** and **q**
5. Perform the _Chinese Remainder Theorem_ on both the **x1** and **x2** to obtain **y** which is the square root of **x** modulus **n**
6. We receives the value **y**

### Solution

We can create a script that consistently sends random $x^2$ value to the server. The idea is that if we manage to find the modular square root of $x^2$, we can use it to factorize the modulus and obtain the prime factors **p** and **q**.

$$y^2 \equiv x^2 \mod n $$

$$y^2 - x^2 \equiv 0 \mod n $$

$$(y+x)(y-x) \equiv 0 \mod n  $$

$$(y+x)(y-x) \equiv k*n $$

$$ (y+x)(y-x) \equiv k*p *q $$


This means that if we compute $\text{gcd(y + x,n)}$ and $\text{gcd(y - x,n)}$, we should be able to obtain the values of **p** and **q**.

```python
from pwn import *
from sympy import *
from Crypto.Util.number import *
while True:
    r = remote("chall.lac.tf",31171)
    #r.interactive()
    exec(r.recvline().decode())
    exec(r.recvline().decode())
    exec(r.recvline().decode())
    print(r.recvuntil("> ").decode())

    try:
        x = randint(0,N//4)
        print(x)
        r.sendline(str((x**2)).encode())
        y = int(r.recvline().decode())
    except:
        continue
    
    print(f"{N = }")
    print(f"{e = }")
    print(f"{ct = }")
    print(f"{y = }")
    a = gcd(y+x,N)
    b = gcd(y-x,N)
    c = ((y+x)*(y-x)) % N
    print(f'{a=}')
    print(f'{b=}')
    print(f'{c=}')
    if c == 0:
        if a != N and b != N:
            break
    r.close()
    
if a == 1:
    p = b
    q = N//b
elif b == 1:
    p = a
    q = N//b
else:
    p = a
    q = b
phi = (p-1)*(q-1)
d = pow(int(e),-1,int(phi))
print(f"{d=}\n")
print(long_to_bytes(pow(int(ct),d,int(N))))
```

### Flag
>lactf{1s_r4bin_g0d?}
