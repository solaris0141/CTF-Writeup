UTAR (University Tunku Abdul Rahman) CTF 2024 
=====

Unfortunately, there were only 1 crypto challenge so I will just write my solving process of it. Most of the challenges are forensics so I won't be writing about it.

---

## crypto/CryptoQuest
#### *source.py*
```python
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from Crypto.Util.Padding import pad
import os


FLAG = b"UTAR{--REDACTED--}UTAR{--REDACTED--}.."


def getPrimes(coefficient):
    while True:
        a = getPrime(512)
        p = 3 * coefficient * a + 2
        if isPrime(p):
            break
    while True:
        b = getPrime(512)
        q = 3 * coefficient * b + 2
        if isPrime(q):
            break
    return p, q


def encrypt(message, coefficient):
    p, q = getPrimes(coefficient)
    n = p * q

    padded_message = bytes_to_long(pad(message, 256))
    message = bytes_to_long(message)

    c1 = (message * (message + coefficient)) % n
    c2 = (padded_message * (padded_message + coefficient)) % n
    return (n, c1, c2)


def main():
    coefficient = getPrime(128)
    out = ""

    message = FLAG[0:len(FLAG)//2]
    n1, c1, c2 = encrypt(message, coefficient)
    out += f"{n1=}\n{c1=}\n{c2=}\n"

    message = FLAG[len(FLAG)//2:]
    n2, c3, c4 = encrypt(message, coefficient)
    out += f"{n2=}\n{c3=}\n{c4=}\n"

    out += f"{len(FLAG)}"

    with open("out.txt", "w") as f:
        f.write(out)
        



if __name__ == '__main__':
    main()
```

#### output.txt
```txt
93768948782729745478599497793422837990844683777054239378160474776560328573740431328119069546474726108930506737169994788955100441012384360021152667154287992695010195576758316949585621551596158372376345419456965488254521532147792713935363300735987030988082563979975500168572577260733535458985853917764527363407769270888828243816895641732445160252301964925541012207546553786760547571437309
3621040439219007434888695593528949492599239288972667623035553668240449325367907807190984382
38961170119626522687626510695512763945837282490901105292914551271909132862880451294564581486215394942213278613219193998476780825416310064483441834455024759682451365186271467161856917087605946914135889892673345642528730827437281612146749527084617454349049733455068960554905116871841706314477013111977569678325423376811306656890003048738805309787387561294793597356241924105500206801243681
91025568464739694140466003159234293768290991283984557403047262623528591078227010433420470804003649933884386662079743329798798525248580861464365943451120270370457258649269769883650838118032727366611574875678349888523527808307940817294050887454976727571614338539148795127773589683011325602555167585577233867721677509481441225602003683137182844508449837448007714031771752450966624270918589
1407336180112944499971322497698050797074666521478341254597057144222846308346063835176567810
66733679878633667124757259223269231432367881207935206058792943692988714505334832943381814065625916206697088774218098846411737964259410579281236726564745615128051703728622261928271407714135067615429579405549983711303762437418267153754333494140843478524850272910127575235376097155240248320583861866005852543936467306384094561646405485745134325827256105810397144185548281681262004671878944
38
```

### Solution 
Essentially, two large primes $p$ and $q$ are generated with the _**getPrime()**_ function based on the 128-bit prime number, **coefficient** which we will call it $c$. The flag is then split in half into $m1$ and $m2$ and encrypted seperately. The _**encrypt()**_ function is as below:

$$c1 \equiv m_i * (m_i + c) \mod n$$

$c2$ is also calculated with the same method as $c1$ just that it has the message padded to 256 bits first, and from what I've analyzed, c2 is completely useless to our solution later on. 
The vulnerable part of this encryption lies on the prime generation function of $p$ and $q$. 

$$ p = (3* c * a_1 + 2) $$

$$ q = (3* c *b_1 + 2) $$

which means

$$ n = (3* c * a_1 + 2)(3* c *b_1 + 2) $$

_ps: the n is then recalculated with another_ $a_2$ _and_ $b_2$ _value for encrypting the second half of the flag_

With all of this prerequisites known, it's clear that finding the value of $c$ will leads to solving this challenge. Since there is two $n$ values, I first thought of possibly using **gcd** to somehow return us with a composite number that has prime factor of $c$ since $d$ is prime. 

$$ n = (3ca_1 + 2)(3cb_1 + 2) $$

$$ n = (3ca_1)(3cb_1) + 6ca_i + 6cb_i + 4 $$

$$ n = 9c^2a_ib_i + 6c(a_i + b_i) + 4 $$


after removing the $4$ and then factorising the equation, we get


$$ n = 3c (a_ib_i + 2(a_i + b_i)) $$

with this now it's clear that gcd is possible for us to obtain the value of $c$. Value of $a$ and $b$ differs a lot between two of the $n$ values so the chances of having a gcd there is low in possibility, at most we would have some noise in the returning value which can be easily factored out.

```sage
n1 = 93768948782729745478599497793422837990844683777054239378160474776560328573740431328119069546474726108930506737169994788955100441012384360021152667154287992695010195576758316949585621551596158372376345419456965488254521532147792713935363300735987030988082563979975500168572577260733535458985853917764527363407769270888828243816895641732445160252301964925541012207546553786760547571437309

n2 = 91025568464739694140466003159234293768290991283984557403047262623528591078227010433420470804003649933884386662079743329798798525248580861464365943451120270370457258649269769883650838118032727366611574875678349888523527808307940817294050887454976727571614338539148795127773589683011325602555167585577233867721677509481441225602003683137182844508449837448007714031771752450966624270918589 

c = gcd((n1-4)/3, (n2-4)/3).factor()[-1][0]
```

running this on sage gave me the 128 bit prime number and confirmed that it is indeed the value of $c$
> c = 317746892711557615738201753984488906029

Now we just need to construct the polynomial equations and use sage to solve it

$$ m*(m + c) = c1 $$

$$ m*(m + c) - c1 = 0 $$

applying this method to c2 and we can get both parts of the flag. 

```sage
from Crypto.Util.number import long_to_bytes
n1 = 93768948782729745478599497793422837990844683777054239378160474776560328573740431328119069546474726108930506737169994788955100441012384360021152667154287992695010195576758316949585621551596158372376345419456965488254521532147792713935363300735987030988082563979975500168572577260733535458985853917764527363407769270888828243816895641732445160252301964925541012207546553786760547571437309

n2 = 91025568464739694140466003159234293768290991283984557403047262623528591078227010433420470804003649933884386662079743329798798525248580861464365943451120270370457258649269769883650838118032727366611574875678349888523527808307940817294050887454976727571614338539148795127773589683011325602555167585577233867721677509481441225602003683137182844508449837448007714031771752450966624270918589 

c = gcd((n1-4)/3, (n2-4)/3).factor()[-1][0]
#c = 317746892711557615738201753984488906029 # in 128 bit

c1 = 3621040439219007434888695593528949492599239288972667623035553668240449325367907807190984382
c2 = 38961170119626522687626510695512763945837282490901105292914551271909132862880451294564581486215394942213278613219193998476780825416310064483441834455024759682451365186271467161856917087605946914135889892673345642528730827437281612146749527084617454349049733455068960554905116871841706314477013111977569678325423376811306656890003048738805309787387561294793597356241924105500206801243681
c3 = 1407336180112944499971322497698050797074666521478341254597057144222846308346063835176567810
c4 = 66733679878633667124757259223269231432367881207935206058792943692988714505334832943381814065625916206697088774218098846411737964259410579281236726564745615128051703728622261928271407714135067615429579405549983711303762437418267153754333494140843478524850272910127575235376097155240248320583861866005852543936467306384094561646405485745134325827256105810397144185548281681262004671878944

var("m1 m2")

poly1 = m1*(m1 + c) - c1
flag1 = int(next(sol[m1] for sol in solve(poly1,m1,solution_dict=true) if sol[m1] > 0))

poly2 = m2*(m2 + c) - c3
flag2 = int(next(sol[m2] for sol in solve(poly2,m2,solution_dict=true) if sol[m2] > 0))

flag = long_to_bytes(flag1) + long_to_bytes(flag2)
print(flag)

```

### Flag
> UTAR{19225ed7185d6b5211065eb201aa9e78}






